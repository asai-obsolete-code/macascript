
;; atom
(maca a)
(maca 2)
(maca "string")

(maca :a)
(maca (gensym))
(let ((a (gensym)))
  (m-compile t (list a)))

;; fundamentals

(maca (glue a 2 space "string" semicolon))

;; glueを外から見えないようにしないとエラーが出る
(maca (paren a))
(maca (comma (comma a b c) (comma a b c)))
(maca (comma a b c))
(maca (blk ((a b c))))

;; constants
(maca undefined)
(maca t)

;; assignments
(maca (= number 3))
(maca (blk (= number 3) (= number 3)))
(maca (blk ((= number 3) (= number 3))))
(maca (comma (= number 3) (= number 3)))
(maca (var number 3))
(maca (var number))
(maca (var (+ 2 1) 3))					;error

;; infix
(maca (>>> number 3))
(maca (+ a 3))
(maca (+ a 3 4))
(maca (+ a 3 (>>> number 3)))

;; comparison
(maca (< number 50))
(maca (== 5 3))
(maca (== 5 3 4))
(maca (>= 5 3 4))

;; mono-ops
(maca (new (number)))
(maca (typeof 5))

;; in
(maca (in 5 array))

;; function definition
(maca (-> (a b c)
	  (= d (- a b c))
	  (+ a b c d)))

;; conditional expression
(maca (if (a b c)
	  (= d (- a b c))))		;one-line
(maca (if (a b c)
	  (= d (- a b c))
	  (= d (- a b c))))		;one-line else
(maca (if (a b c)
	  ((= d (- a b c))
	   (= d (- a b c)))
	  (= e (+ a b c d))))		;multi-line then

(maca (if (a b c)			;multi-line then/else
	  ((= d (- a b c))
	   (= e (+ a b c d)))
	  ((= e (+ a b c d))
	   (= d (- a b c)))))

(maca (? a b c))
(maca (? a))

;; object accessor
(maca (:a a :b (b c) :c (+ 1 2 3)))
(maca (obj > attibute))
(maca (obj > child > grandchild))
(maca (granpa > parent > obj > child > grandchild))
(maca (obj > (child) > (grandchild)))
(maca (obj > (child) > grandchild))
(maca (obj -> child))
(maca (obj -> (method)))

(maca (a ? b))
(maca (a ? b ? c))

(maca (a > b ? c ? d > (e) > (f) ?  g -> h))

;; try-catch-finally

(maca (try ((drink 3 "beer")
			(eat 5 pizza))
		   catch (x)
		   ((if (== x "drunkTooMuch")
				(puke)
				(take digestive)))
		   finally
		   ((pay money)
			(go home))))

;; # Assignment:
;; number   = 42
;; opposite = true

;; done
(= number 42)
(= opposite true) 

;; set has almost the same meaning as =,
;; but it has the setf feature
(set opposite on) 
(set opposite yes)

(eq true on yes t)						;-> t
(eq false off no t)						;-> t


;; CS	JS          MS
;; is	===         eq
;; isnt	!==         neq
;; not	!           not
;; and	&&          and
;; or	||          or

;; numerical operation

;; >,<,>=,etc...


;; true, yes, on	true
;; false, no, off	false
;; @,this	this
;; of	in          has
;; in	no JS equivalent

;;      void 0      nil,undefined

;; # Objects:
;; math =
;;   root:   Math.sqrt
;;   square: square
;;   cube:   (x) -> x * square x

;; key-value store
(:a 1 :b 2 :c 3)

;; # Conditions:
;; number = -42 if opposite

(if opposite (= number -42))

(= number -42 if opposite)			;in any last part of parenthesis

;; # Functions:
;; square = (x) -> x * x
;; 
;; same as cl. &rest, &key, &optional is available
(= square (-> (x) (* x x)))

;; # Arrays:
;; list = [1, 2, 3, 4, 5]
;; 
;; no comma needed. its just a list
(= lst (1 2 3 4 5))

;; # Existence:
;; alert "I knew it!" if elvis?

(if (? elvis) (alert "I knew it"))

;; chaining / object accessor
;; 
;; animal.human.eat(food).drink(coke)

((animal > human > eat food) > drink coke)

;; maca will not think the bracket as a comparison token, because
;; it will never be at the first symbol of the list.


;; Existential operator
;; 
;; animal.human?.eat?(food).drink(coke)
((animal ? human ? eat food) > drink coke)


;; prototype operator
;; 
;; String::dasherize

(set (String :: dasherize) (-> (dosomething)))

;; # Array comprehensions and for statements etc.
;; cubes = (math.cube num for num in list)

;; it returns a value if it should
(for num in list
  (math > cube num))


;; destructuring-bind is almost the same as common-lisp but its 
;; name "bind", not "destructuring-bind".
;; 
;; bind creates a closure.
(bind (x y) (/ a b)
  (dosomething))

;; this does not create a closure. the argument should be quoted
(set '(x y) (/ a b))

;; setf feature is provided.
;; it throws an error if the first argument does not return Object.

(set setfary 
	 (setf->
	  (-> (ary x) (ary > x))	; return ary[x]
	  (-> (ary x)
		  (-> (value)
			  (set (ary > x) value)))))


;; At last, of course, MACRO. 
;; gensym is available.
;; ONLY IN THE COMPILATION TIME does Maca turn out to be a lisp.

(defmacro (valname &body body)
	(let ((x (gensym)))
	  `(let ((,x 3))
		 (print ,x)
		 ,@body)))